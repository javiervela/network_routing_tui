\documentclass{article}
% \documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
% \usepackage[spanish]{babel}
% \usepackage{fontspec}

% Packages for formatting
% \usepackage{indentfirst}

% Packages for math and proofs
\usepackage{amsmath, amssymb, amsthm}

% Packages for code formatting
\usepackage{listings}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{chngpage}
\usepackage{amsfonts}
 \usepackage{mathtools}

% Packages for graphics and images
\usepackage{graphicx, eso-pic}
\usepackage{float}

% Packages for hyperlinks and document references
\usepackage{hyperref}

% Packages for colors
\usepackage{xcolor}

% Package for modifying titles
% \usepackage{titling}

% Packages for tables
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{longtable}

% Package for headers and footers
\usepackage{fancyhdr}

% Package for setting page margins
% \usepackage[a4paper, margin=1in]{geometry}

% Package for customizing lists
\usepackage{enumitem}

% Package for URLs
\usepackage{url}

% Package for page size
\usepackage[letterpaper, margin=1in]{geometry}

% Package for line spacing
\usepackage{setspace}
\setstretch{1.2}

\usepackage{titlesec}

% inhibit page breaks in the middle of paragraphs
\widowpenalties 1 10000
\raggedbottom

% Define colors for code formatting
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{codeborder}{rgb}{0.8,0.8,0.8}

% Listings settings for code formatting
\lstset{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    rulecolor=\color{codeborder},
    numbers=left,
    numberstyle=\tiny\color{gray},
    xleftmargin=15pt,
    framexleftmargin=15pt,
    captionpos=b, % Position the caption below the listing
    keywordstyle=\color{blue}, % Color the keywords
    commentstyle=\color{green!60!black}, % Color the comments
    stringstyle=\color{red}, % Color the strings
}


% Custom parameters
\newcommand{\assignmentname}{Final Project: Routing Algorithms}
\newcommand{\subjectname}{CS513: Computer Networks}
\newcommand{\titletext}{\assignmentname}

\newcommand{\studentone}{Automne Petitjean}
\newcommand{\studentoneemail}{mpetitjean@wpi.edu}
\newcommand{\studenttwo}{Javier Vela Tambo}
\newcommand{\studenttwoemail}{jvela@wpi.edu}

\author{\studentone \\ \texttt{\studentoneemail} \and \studenttwo \\ \texttt{\studenttwoemail}}

% \newcommand{\submissiondate}{\today}
\date{\today}

\newcommand{\logo}{logo/wpi.png}
\newcommand{\logoheader}{logo/wpi_header.png}

\title{
    \vspace{0.5cm}
    \titletext \\
    \vspace{0.35cm}
    \large \subjectname
}

% Title formatting
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}

% Add pictures after the title, in the foreground
\AddToShipoutPictureFG*{
    \AtPageUpperLeft{
        \hspace*{\dimexpr\oddsidemargin + \hoffset + 1.5in\relax}
        \raisebox{\dimexpr-\height-2\baselineskip}{
            \makebox[0pt]{\includegraphics[width=5cm]{\logo}}}}
    % 2nd picture on the right
    % \AtPageUpperLeft{
    %     \hspace*{\dimexpr\oddsidemargin + \textwidth + \hoffset + 1.5in - 5cm\relax}
    %     \raisebox{\dimexpr-\height-2\baselineskip}{
    %         \makebox[0pt]{\includegraphics[width=5cm]{\logo}}}}
}

% Header setup
\pagestyle{fancy}
\fancyhf{}
\lhead{\includegraphics[height=0.5cm]{\logoheader}}
\rhead{\textbf{\subjectname}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\setlist[itemize]{partopsep=0pt, parsep=0pt, itemsep=0.2em, left=1.5em}
\setlength{\parskip}{0.5em}


\begin{document}

\thispagestyle{empty}

\maketitle

% TODO check bellow before closing report

% The ﬁnal report should be a well-presented technical report discussing your project (in pdf format). If your project is primarily a programming eﬀort, you should explain how the program works, give speciﬁc sample runs and analyze the results. The report should be 5-10 pages in length, although may be less if you do the standard project. If your project team is more than one person then the report should indicate what each person did on the project.”
% 
% - 5-10 pages in length
% - you should explain how the program works
% - give speciﬁc sample runs
% - analyze the results.
% - indicate what each person did on the project.
%
% Again, the ﬁnal project and report are due Friday, December 13, 2025.
% 
% ## Report Details
% 
% In addition to the overview provided above, your report needs to address each of the following questions. You are encouraged to explicitly use this format in organizing your report.
% 
% - What is your name(s)?
% - What project did you select?
% - Describe the work did you do on the project including any deviations from the description if you chose standard project.
% - What are the results you obtained? As appropriate, it is important you include sample output demonstrating functionality/results of your project.
% - What went well on the project?
% - What did you learn?
% - What was hard?
% - What, if anything, did you do beyond the standard project description (if you based your project on it)?
% - What, if anything, did you not complete that was in the basic project description or your initial design?

\section{Introduction}

% - What project did you select?

For the final project, we selected the standard ``Network Layer Routing'' project. The goal of the project is to develop an application to create different network topologies (represented as graphs), execute the Link State and Distance Vector routing algorithms, and query the routing tables for each network node. We implemented the basic requirements of the standard project and extend it with additional features and analysis. Our main contributions are the following:

\begin{itemize}
    \item A Textual User Interface (TUI) to interact with the application.
    \item Additional features:
          \begin{itemize}
              \item Visualization of the network topology.
              \item Save and load network topologies from files.
              \item Load scripted commands from a file to automate tests.
          \end{itemize}
    \item A variation of the distance vector algorithm that includes a ``via'' field in the routing table to prevent ``counting to infinity'' issues.
    \item An analysis of the performance of the algorithms implemented.
\end{itemize}

The application is implemented in Python and is available at the \url{https://github.com/javiervela/network_routing_tui}. The \href{https://github.com/javiervela/network_routing_tui/blob/main/README.md}{\texttt{README} file} provides instructions on how to install and run the application, and many details and examples of its usage.

The rest of the report is organized as follows: Section \ref{sec:implementation} describes the implementation of the project, including the algorithms used. Section \ref{sec:results} presents the experimentation and results obtained. Finally, Section \ref{sec:conclusions} concludes the report with reflections on the project.

\section{Implementation} \label{sec:implementation}

In this section, we describe the details of the main two components of the project: the algorithms used and the application interface.

\subsection{Algorithms}

In this project, we implement two different algorithms: the distance vector algorithm and the link state algorithm. For the distance vector algorithm, we implemented two variations: the classical version (which we call legacy) and our own enhanced version that includes a ``via'' field in the routing table to prevent counting to infinity issues. In the analysis section, we compare both versions of the distance vector algorithm to get an idea of the benefits of our enhancement.

\subsubsection*{Link State}

The Link State (\texttt{LS}) algorithm is a simple graph traversal that looks at all the possible routes from one specific source node. It uses Dijkstra's algorithm to find the shortest path from the source node to all other nodes in the graph. The algorithm maintains a priority queue of nodes to explore, ordered by their current known distance from the source node. Because the algorithm has a global view of the graph, it converges immediately to the optimal routing table for the source node.

\subsubsection*{Distance Vector (legacy)}

The Distance Vector algorithm is a distributed algorithm where each node only knows about its direct neighbors and the cost to reach them. Each node maintains a routing table that contains the best known distance to each destination node in the network. The algorithm works by exchanging routing tables between neighboring nodes and updating the routing table based on the received information.

The Distance Vector algorithm is run step by step. During one step, each node sends its current routing tables to all its neighbors. To simulate this sending process, we save a copy of all the routing tables at time $t$. Then this copy is given to each neighbor and used to build the new routing table at time $t+1$.

The new table for $A$ at $t+1$ is built by creating a table with only one route: the route to $A$ with a distance of 0. It is then updated by the received tables from all neighbors. In our experiment, all tables are sent and received simultaneously. In a context where tables arrive irregularly, we would need to remove only the routes going through $B$ when receiving a table from $B$. We would also need to remove routes going through neighbors when we detect that we're not connected to them anymore.

When receiving a table from a neighbor, a node uses it to update its own table. Let's call $A$ the receiving node and $B$ the sender. $A$ compares each route in the $B$ table (to which the distance from $A$ to $B$ has been added) with the routes it already knows and keep the shortest option.

Given that the algorithm only has a local view of the graph, it may take several iterations to converge to the optimal routing table.

This is the classical distance vector algorithm that suffers from counting to infinity problems. These problems arise when a link goes down or its cost increases significantly. Nodes may continue to believe that they can reach a destination through a neighbor, leading to incorrect routing information that propagates through the network. We refer to this version as ``legacy'' (\texttt{DV-l}) in this report.

\subsubsection*{Distance vector (enhanced)}

In the distance vector algorithm legacy version, tables sent only contains a destination and a distance for each routes, leading to ``counting to infinity'' issues. As an ``enhanced'' (\texttt{DV-e}) version of the distance vector algorithm, we added a ``via'' field to each route in the routing table. This allows a certain node to ignore routes that go through itself. If $B$ thinks it can reach $C$ through $A$, $A$ necessarily knows better and doesn't need this information. Taking it into account runs the risk of propagating wrong information.

\subsection{Application Interface}

The application provides a Textual User Interface (TUI) that allows users to interact with the network routing algorithms. The TUI is built using the \texttt{textual} Python library, which provides a rich set of widgets and layout options for building terminal-based applications. The application allows users to create network topologies, run the routing algorithms, and visualize the results. The TUI is designed to be user-friendly and intuitive. Figure \ref{fig:tui} shows a screenshot of the TUI.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{../images/tui_wallpaper.png}
    \caption{Textual User Interface of the application}
    \label{fig:tui}
\end{figure}

The application also supports a Command Line Interface (CLI) mode, which allows users to run the application without the TUI. This mode is useful for automated testing and scripting. The CLI mode accepts commands as arguments and executes them directly. Both modes share the same commands shown in Table \ref{tab:commands}. The Distance Vector algorithm for the \texttt{DV} command corresponds to our enhanced version.

\begin{table}
    \begin{center}
        \caption{List of commands supported by the application}
        \label{tab:commands}
        \begin{tabular}{|l|l|}
            \hline
            \textbf{Command}              & \textbf{Description}                               \\
            \hline
            \texttt{X Y COST}             & Add or update edge X-Y with given COST             \\
            \hline
            \texttt{X Y -}                & Remove edge between nodes X and Y                  \\
            \hline
            \texttt{ls X}                 & Run Link State from node X                         \\
            \hline
            \texttt{dv X}                 & Run one Distance Vector iteration; print X's table \\
            \hline
            \texttt{show}                 & Display the graph in a window                      \\
            \hline
            \texttt{saveg FILE}           & Save graph to FILE                                 \\
            \hline
            \texttt{savert X FILE}        & Save routing table of node X to FILE               \\
            \hline
            \texttt{print X}              & Print routing table for node X                     \\
            \hline
            \texttt{load FILE}            & Load graph from FILE                               \\
            \hline
            \texttt{clear}                & Remove all nodes and edges                         \\
            \hline
            \texttt{help}                 & Show help                                          \\
            \hline
            \texttt{quit} / \texttt{exit} & Exit                                               \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

For more information and examples on the usage of the application or if you want to try it out, please refer to the \href{https://github.com/javiervela/network_routing_tui}{project repository}.


\section{Experimentation and Results} \label{sec:results}

% TODO BLABLABLA

\subsection{Error Metrics}

In this report we measure the errors in routing tables when using \texttt{DV} (either enhanced \texttt{DV-e} or legacy \texttt{DV-l}) compared to \texttt{LS}. We want to know in how many iterations of \texttt{DV} the routing table reaches an accurate result. There are several ways of measuring the difference between the ideal routing table, obtained from \texttt{LS}, with the routing table from \texttt{DV} at step $t$. Let us describe the various metrics used and their advantages and disadvantages.

First, here are the notations we will use throughout this section:

\begin{itemize}
    \item $G$ the graph
    \item $A$, $B$, $C$... nodes in graph $G$
    \item $d_{ls}(A,B)$ the distance between A and B as given by the link state algorithm
    \item $d_{t}(A,B)$ with $t \in \mathbb{N}$ the distance between A and B in the routing table of A after $t$ iterations.
\end{itemize}

A naïve way to measure the error would be to do this:

$naiveError_{t} = \sum_{A \in G} \sum_{B \in G} |d_{ls}(A,B) - d_{t}(A,B)|$

This, however, presents some problems. Firstly, it is ill defined for cases where $A$ and $B$ are not connected or when the \texttt{DV} routing table doesn't know how to reach $B$ even though a route exists. We can imagine another version:

$numberErrors_{t} = \sum_{A \in G} \sum_{B \in G} 1 - \delta_{d_{ls}(A,B), d_{t}(A,B)}$ with  $\delta_{a,b}  = \begin{cases*}
        1 & if  $a = b$ \\
        0 & otherwise
    \end{cases*}$

This would count exactly the number of routes for which the \texttt{DV} table has a different distance from the ideal route. While this is an appropriate measure, it doesn't help in cases where the routing table knows of the correct distance but the route itself doesn't match.

For this we have to introduce a new notation: $msg_t(A,B)$ is the time it takes a message to go from $A$ to $B$ following the routes given by the \texttt{DV} algorithm at step $t$.

Due to the nature of this measure, it can only be computed when all nodes in the graph have a routing table computed by \texttt{DV}. Some messages may never reach their destination, either because they reach a node that doesn't know how to reach said destination or because it gets stuck in an infinite loop between two nodes (for this specific case we implemented a hop limit). It allows us imagine this error metric:

$msgError_t = \sum_{A \in G} \sum_{B \in G} 1 - \delta_{d_{ls}(A,B), msg_{t}(A,B)}$

This metric is still not perfect. It doesn't take into account that some routing tables can have a correct route stored with a wrong distance. We argue that it is a good metric as it is close real world expectations of routing tables. Each error means that a message took longer to reach the destination than the ideal route. We can also measure only the message that failed to reach their destination. Sending a message through a non-efficient route is less of an issue than being unable to reach the destination at all even though a route exists.

\subsection{Performance Comparison of Distance Vector Implementations} % TODO check title makes sense

% TODO dv-l vs. dv-e performance comparison, analysis of count to infinity problem

The proposed \texttt{DV-e} algorithm aims to fix the problem of the ``count to infinity'' posed by \texttt{DV-l}. Figure \ref{fig:armand} shows a simple example graph. We assume that \texttt{DV} has been run enough time so that the routing tables are correct. If the edge between $A$ and $B$ suddenly becomes 300, the legacy algorithm will take a long time before correcting the routing tables as shown in Figure \ref{fig:armand_legacy}.

\begin{center}
    \begin{minipage}{0.49\textwidth}
        \refstepcounter{figure}\label{fig:armand}
        \centering
        \includegraphics[width=\linewidth]{../images/infinity.png}
        \par\noindent Figure \thefigure: A simple example graph named Armand.
    \end{minipage}\hfill
    \begin{minipage}{0.49\textwidth}
        \refstepcounter{figure}\label{fig:armand_legacy}
        \centering
        \includegraphics[width=\linewidth]{../images/infinity_legacy.png}
        \par\noindent Figure \thefigure: Evolution of the $msgError$ during 500 iterations of the \texttt{DV-l} algorithm.
    \end{minipage}
\end{center}

This is a good illustration of counting to infinity. The bad news took a long time to travel, $B$ and $C$ remain convinced that they can reach A by going through each other, meaning that all messages from $B$ or $C$ to $A$ are lost until the count reached 300. Meanwhile, the \texttt{DV-e} algorithm doesn't have any error and after two steps, the routing tables are updated with the correct distances. The absence of errors can be explained by the fact that $B$ refused to take a route from $C$ that would go through itself thus avoiding the infinite loop route that loses messages.

However, our algorithm is not immune to ``count to infinity'' problems, we just have to find another example like the one in Figure \ref{fig:beatrice}. If we then remove the edge between $C$ and $D$, and make the edge between $A$ and $D$ more expensive, the \texttt{DV-l} algorithm will count to infinity. $A$, $B$ and $C$ will create a loop-route between themselves and never know that it loops. \texttt{DV-e} is therefore not perfect.

\begin{center}
    \begin{minipage}{0.49\textwidth}
        \refstepcounter{figure}\label{fig:beatrice}
        \centering
        \includegraphics[width=\linewidth]{../images/devious.png}
        \par\noindent Figure \thefigure: Another example graph named Béatrice.
    \end{minipage}\hfill
    \begin{minipage}{0.49\textwidth}
        \refstepcounter{figure}\label{fig:charles}
        \centering
        \includegraphics[width=\linewidth]{../images/charles.png}
        \par\noindent Figure \thefigure: If you set the weight of edge AB to 50, \texttt{DV-l} will converge in 2 steps, whereas \texttt{DV-e} will converge in 3.
    \end{minipage}
\end{center}

Looking further into this, we can find examples where \texttt{DV-e} is slower to converge than \texttt{DV-l}. The counter examples were found by going through random graphs. We decided to investigate deeper into the benefits of  \texttt{dv-e}. Figure \ref{fig:charles} shows one of these counter examples.

\begin{table}[h!]
    \begin{center}
        \caption{Average number of steps to converge for \texttt{DV-l} compared to \texttt{DV-e} depending on the number of nodes in the graph and the density p. (positive numbers mean \texttt{DV-l} take more steps than \texttt{DV-e}).}
        \label{tab:results1}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Number of Nodes & p=0.1 & p=0.5 & p=0.9 \\
            \hline
            4               & 81.33 & 89.51 & 88.2  \\
            \hline
            6               & 42.87 & 50.77 & 48.47 \\
            \hline
            8               & 12.64 & 17.89 & 15.75 \\
            \hline
            10              & 4.8   & 2.88  & 3.65  \\
            \hline
            12              & 0.51  & 1.15  & 1.3   \\
            \hline
            14              & 0.27  & 0.31  & 0.59  \\
            \hline
            16              & 0.18  & 0.49  & 0.28  \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

We compared both algorithms on graphs randomly generated by two parameters: the number of nodes and the probability p of an edge between two nodes. For each of these graph we chose an edge that will be damaged (its weight will be set to 500). We compare the number of steps it takes for \texttt{DV-e} to converge compared to \texttt{DV-l}. According to the results show in Table \ref{tab:results1}, the density of the graph doesn't seem to affect the relative performance. On the contrary, the number of nodes has a massive influence. Our method is barely even better when the graphs get bigger, averaging 0.26 less steps for graphs with 16 nodes.

At this step, we can make the hypothesis that with bigger graphs, the risk of counting to infinity is lower, thus reducing the usefulness of \texttt{DV-e}. But we would like confirmation of that. That's why we decided to count the number of time count to infinity happens. In order to check if a count to infinity is happening, we measure the convergence time of \texttt{DV-l} on the same graph twice. The first time we increase the chose edge weight to 100, the second time we increase it to 150. If the algorithm takes longer in the second case, it is because it needs time to count the extra 50.

\begin{table}[h!]
    \begin{center}
        \caption{Percentage of count to infinity depending on node amount and density.}
        \label{tab:results2}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Number of Nodes & p=0.1  & p=0.5  & p=0.9  \\
            \hline
            4               & 52.8\% & 49.6\% & 45.2\% \\
            \hline
            6               & 21.0\% & 20.4\% & 22.6\% \\
            \hline
            8               & 3.6\%  & 6.4\%  & 4.4\%  \\
            \hline
            10              & 0.6\%  & 1.0\%  & 1.0\%  \\
            \hline
            12              & 0.2\%  & 0.2\%  & 0.0\%  \\
            \hline
            14              & 0.0\%  & 0.0\%  & 0.2\%  \\
            \hline
            16              & 0.0\%  & 0.0\%  & 0.0\%  \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

The results in Table \ref{tab:results2} show that there seems to be a correlation between the number of count to infinity and the relative efficiency of our algorithm. At least we know it does what it was designed to do which is avoid some counts to infinity.

\section{Conclusions} \label{sec:conclusions}

% - What went well on the project?
% - What, if anything, did you not complete that was in the basic project description or your initial design?

The project was developed successfully and smoothly, with both team members contributing effectively to the implementation and testing of the algorithms. We distributed well the tasks and completed them timely, communicating often and as needed. Everything went according to plan, and we were able to meet all the requirements of the project and all the proposed extensions.

% - What, if anything, did you do beyond the standard project description (if you based your project on it)?

Beyond the basic requirements, we were able to implement additional features that enhanced the user experience and provided more functionality to the application. The application provides an intuitive and interactive TUI, which enabled users to easily create and manipulate network topologies and visualize the changes in the routing tables after executing the algorithms. Additionally, we implemented our own variation of the distance vector algorithm and extensively analyzed it an compared it to the basic implementation.

% - What did you learn?

As an outcome of the project, we gained a deeper understanding of network routing algorithms, which turned out to be very helpful during the final exam. We learned that our variation of the distance vector algorithm can effectively mitigate some of the issues associated with counting to infinity, although it is not a complete solution. Also, we learned how to design and implement a text-based interface using Python, which was a valuable experience in terms of software development and design.

% - What was hard?

We did not encounter significant difficulties during the project. However, implementing the routing algorithms was an application challenging to debug, ensuring that the routing tables were updated correctly after each iteration. This problem was partially solved by the interface, which is more user-friendly than a lot of print statements. Additionally, designing the TUI required a lot of time tuning the different components, ensuring a visually pleasing and comfortable user experience.

% - Recap results % TODO

\section*{Author Contributions}

Conceptualization: A.P., J.V.T.; Algorithm Implementation: A.P.; Interface Implementation: J.V.T.; Testing: A.P., J.V.T.; Experimentation and Result Analysis: A.P., J.V.T.; Documentation and Report: A.P., J.V.T.

\end{document}